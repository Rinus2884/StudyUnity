//New input sysyem

//예전 방식의 Input 클래스를 이용한 키입력에 따른 처리 코드

//if(input.GetKey(keyCode.UpArrow))
//{
//    임의의 처리
//}

//너무 구체적(키보드가 있다고 가정하고, 위쪽 화살표가 있다고 가정하고 그것에 대한 입력이 있다고 가정하고)이다.

////이러한 코드들은 너무 구체적이라서
////임의의 여러가지 경우를 모두 대비할 수 없다.

//게다가 소스코드 상에 위치하고 있어 수정이 발생할 수 박에 없다.

////<-- 보다 일반화된 입력처리 시스템을 만들어 놓은 것이 InputSystem이다.

////N개 종류의 플랫폼 - n개 종류의 입력방식 ---임의의 처리.
///


/*inputActions애셋
    ActionMaps      //<-- 액션의집합
        Actions 0
            :Binding
                Binding
                Binding

        Actions 1
        :Binding
        


    Schema: '임의의 플랫폼에 임의의 입력을 조합'시켜 놓은 '카테고리'를 스키마로 명명하였다.

    playerInput컴포넌트에서 schema를 선택가능하다.
    <-- 이것은 해당 프로젝트가 어떤 플랫폼으로 빌드되냐에 따라 선택하면 된다.
                 WindowPC <--controlSchemaWindPC
                 Android <-- controlSchemaAndroid


    <-- Anmy로 두면 유니티가 알아서 선택해준다.


    ---소스코드상에서 '임의의 처리'를 어떤 방식으로 처리할 것인가 --
    PlayerInput컴포넌트에 Behaviour항목을 보면
    크게 두가지로 처리할 수 있게 되어 있다.

    i)메시지 처리 방식 유니티 에ㅌ디터에 PlayerInput컴포넌트의 behaviour에 Send Message등을 설정한다.
        소스코드에 연동할 함수를 작성한다. 이름 규칙은 On접두사를 액션이름 앞에 붙여 만든다.

    ii)이벤트 처리 방식 <-- 유니티 에디터에 PlayerInput컴포넌트의 behaviourr 밑에, 이벤트에 대응되는 슬롯을 만들고
    거기에 호출할 함수를 연동하면 된다.
    이름 규칙은 별도로 없다.

    --- 메시지, 이벤트 등은 함수 호출을 데이터 관점에서 극도로 추상화해놓은 것이다.
    이렇게 되면 호출에 대해 시간(호출 시점)과 공간(호출할 코드가 어느 코드 위치에 있는지)을 분리할 수 있다.


    step_2 에서는 서로 다른 ActionMaps를 만들어 교체해보는 테스트를 수행
    이로서 알 수 있는 것은
    새로운 Input System이
    추상화된 단위로 매우 유연한 구조를 가지고 있다는 것이다.



    step_3에서는 서로 다른 스키마를 만들어
    적용해보는 테스트를 수행하였다.
    이로서 알 수 있는 것은
    'n개 종류의 플랫폼'을 'm개 종류의 입력방식 ---- 임의의 처리'에 조합할 수 있는
    유연한 구조를 가지고 있다는 것이다.
    
    (<ㅡ테스트 시 AutoSwitchs는 꺼두고 테스트해본다.)

*/